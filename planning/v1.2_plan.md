# v1.2 — Breaking Changes + Observabilidade

Sem fallbacks para legado. Agent e Server v1.2 são incompatíveis com v1.1.x.

---

## Fase 1 — Config: Schedule por Backup Entry

#### [MODIFY] [agent.go](file:///home/lucas/Projects/n-backup/internal/config/agent.go)

- `BackupEntry`: adicionar `Schedule string` (obrigatório, cron expression)
- `DaemonInfo`: remover campo `Schedule` (struct vazio ou removido)
- `LoggingInfo`: adicionar `File string` (path para log file, ex: `/var/log/nbackup/agent.log`)
- Validação: cada `backups[].schedule` deve ser cron válida

#### [MODIFY] [agent.example.yaml](file:///home/lucas/Projects/n-backup/configs/agent.example.yaml)

```yaml
backups:
  - name: "app"
    storage: "scripts"
    schedule: "0 2 * * *"           # Cron por backup
    # ...
  - name: "home"
    storage: "home-dirs"
    schedule: "0 */6 * * *"
    # ...

logging:
  level: info
  format: json
  file: /var/log/nbackup/agent.log  # Novo: log file dedicado
```

#### [MODIFY] [config_test.go](file:///home/lucas/Projects/n-backup/internal/config/config_test.go)

Atualizar testes para `schedule` por entry e `logging.file`.

---

## Fase 2 — Scheduler: N Cron Jobs + Guard de Execução

#### [MODIFY] [scheduler.go](file:///home/lucas/Projects/n-backup/internal/agent/scheduler.go)

Substituir scheduler único por **N jobs independentes**:

```go
type BackupJob struct {
    entry   config.BackupEntry
    mu      sync.Mutex
    running bool
}
```

Cada `BackupJob.execute()`:
1. Lock → se `running`, loga `WARN "backup already running, skipping"` → return
2. Chama `RunBackupWithRetry` para aquele entry
3. Unlock

#### [MODIFY] [daemon.go](file:///home/lucas/Projects/n-backup/internal/agent/daemon.go)

`RunDaemon` registra um cron job por `cfg.Backups` entry. `RunAllBackups` (`--once`) continua sequencial sem guard.

---

## Fase 3 — Protocolo: BackupName no Handshake

#### [MODIFY] [writer.go](file:///home/lucas/Projects/n-backup/internal/protocol/writer.go)

```diff
-func WriteHandshake(w io.Writer, agentName, storageName string) error {
+func WriteHandshake(w io.Writer, agentName, storageName, backupName string) error {
```

Formato: `[Magic 4B] [Version 1B] [Agent\n] [Storage\n] [BackupName\n]`
`ProtocolVersion` → `0x02`

#### [MODIFY] [reader.go](file:///home/lucas/Projects/n-backup/internal/protocol/reader.go)

`ReadHandshake` lê terceiro campo `BackupName`.

#### [MODIFY] [frames.go](file:///home/lucas/Projects/n-backup/internal/protocol/frames.go)

Adicionar `BackupName string` ao struct `Handshake`.

---

## Fase 4 — Agent: Enviar BackupName

#### [MODIFY] [backup.go](file:///home/lucas/Projects/n-backup/internal/agent/backup.go)

Passar `entry.Name` em `WriteHandshake`.

---

## Fase 5 — Server: Subdiretório por BackupName

#### [MODIFY] [handler.go](file:///home/lucas/Projects/n-backup/internal/server/handler.go)

- Ler `backupName` do handshake
- Passar para `NewAtomicWriter`
- Lock key: `agentName:storageName:backupName`

#### [MODIFY] [storage.go](file:///home/lucas/Projects/n-backup/internal/server/storage.go)

```diff
-func NewAtomicWriter(baseDir, agentName string) (*AtomicWriter, error) {
+func NewAtomicWriter(baseDir, agentName, backupName string) (*AtomicWriter, error) {
+    agentDir := filepath.Join(baseDir, agentName, backupName)
```

Resultado: `{baseDir}/{agentName}/{backupName}/{timestamp}.tar.gz`

#### [MODIFY] [integration_test.go](file:///home/lucas/Projects/n-backup/internal/integration/integration_test.go)

Atualizar `WriteHandshake` e `NewAtomicWriter` com `backupName`.

---

## Fase 6 — Logging: File Output Dedicado

#### [MODIFY] [logger.go](file:///home/lucas/Projects/n-backup/internal/logging/logger.go)

Adicionar suporte a output para arquivo:

```go
func NewLogger(level, format, filePath string) *slog.Logger {
    var w io.Writer = os.Stdout
    if filePath != "" {
        f, _ := os.OpenFile(filePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        w = io.MultiWriter(os.Stdout, f) // stdout + file
    }
    // handler com w em vez de os.Stdout
}
```

> [!TIP]
> `MultiWriter` mantém stdout para `journalctl` enquanto grava no arquivo dedicado.

#### [MODIFY] [main.go (agent)](file:///home/lucas/Projects/n-backup/cmd/nbackup-agent/main.go)

Passar `cfg.Logging.File` para `NewLogger`.

#### [MODIFY] [main.go (server)](file:///home/lucas/Projects/n-backup/cmd/nbackup-server/main.go)

Idem.

#### [MODIFY] [build-deb.sh](file:///home/lucas/Projects/n-backup/packaging/build-deb.sh)

Criar `/var/log/nbackup/` no postinst do `.deb` com owner `nbackup:nbackup`.

---

## Fase 7 — Daemon: Job Listing no Startup

#### [MODIFY] [daemon.go](file:///home/lucas/Projects/n-backup/internal/agent/daemon.go)

Na inicialização do `RunDaemon`, após registrar todos os cron jobs, logar tabela de jobs:

```json
{"level":"INFO","msg":"registered backup job","backup":"app","storage":"scripts","schedule":"0 2 * * *","parallels":0}
{"level":"INFO","msg":"registered backup job","backup":"home","storage":"home-dirs","schedule":"0 */6 * * *","parallels":32}
```

---

## Fase 8 — Stats Periódicas (Heartbeat de Observabilidade)

#### [NEW] [stats_reporter.go](file:///home/lucas/Projects/n-backup/internal/agent/stats_reporter.go)

Goroutine que a cada **5 minutos** loga métricas JSON do daemon:

```json
{
  "level": "INFO",
  "msg": "daemon stats",
  "uptime_seconds": 3600,
  "jobs_total": 2,
  "jobs_running": 1,
  "last_backup": {
    "name": "app",
    "status": "completed",
    "duration_seconds": 42,
    "bytes_transferred": 1073741824,
    "objects_count": 1500,
    "throughput_mbps": 24.3,
    "timestamp": "2026-02-14T02:00:42Z"
  },
  "next_scheduled": {
    "name": "home",
    "at": "2026-02-14T06:00:00Z"
  }
}
```

#### [MODIFY] [scheduler.go](file:///home/lucas/Projects/n-backup/internal/agent/scheduler.go)

Cada `BackupJob` armazena `lastResult` (status, duração, bytes, objetos, timestamp) após execução para o stats reporter consultar.

#### [MODIFY] [daemon.go](file:///home/lucas/Projects/n-backup/internal/agent/daemon.go)

Iniciar `StatsReporter` goroutine junto com o scheduler. Parar no shutdown.

---

## Verificação

```bash
go test ./... -count=1
```

### Checklist
- [ ] Config sem `daemon.schedule` carrega corretamente
- [ ] Cada backup tem seu cron independente no daemon
- [ ] Guard: backup em execução é skippado no re-trigger
- [ ] Server cria subdiretório `{agent}/{backup}/`
- [ ] Rotação isolada por subdiretório
- [ ] Log grava em `/var/log/nbackup/agent.log` (e stdout)
- [ ] Jobs listados no startup do daemon
- [ ] Stats JSON a cada 5min no log
- [ ] `--once` roda tudo sequencialmente sem guard
