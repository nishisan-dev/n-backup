# Fix: Flow Rotation Race Condition e Deadlock de Streams

## Causa Raiz

O bug envolve **dois problemas combinados** em [handler.go](file:///home/lucas/Projects/n-backup/internal/server/handler.go):

### Bug 1: Race Condition nos Contadores

No `StartStatsReporter` (a cada 15s):
1. `logPerStreamStats(secs)` é chamado **primeiro** (L116) → faz `counter.Swap(0)` em cada `StreamTrafficIn` → **reseta para zero**
2. `evaluateFlowRotation(secs)` é chamado **depois** (L121) → faz `counter.Load()` → **lê zero**

```diff
 // Dentro de logPerStreamStats:
-bytes := counter.Swap(0)    // <-- RESETA!
 // Dentro de evaluateFlowRotation:
-bytes := counter.Load()     // <-- SEMPRE LÊ 0, porque já foi resetado acima!
```

> [!CAUTION]
> Como resultado, `evaluateFlowRotation` **sempre** calcula `mbps=0`, marcando **todos** os streams como degradados. Após `EvalWindow` (60min), **todos** os streams são rotados simultaneamente.

### Bug 2: Rotação em Massa (sem limite)

Quando `EvalWindow` expira, `evaluateFlowRotation` fecha **TODOS** os streams de uma vez:
- 12 streams têm suas conexões fechadas simultaneamente
- Os 12 senders do agente entram em backoff + reconnect ao mesmo tempo
- Nenhum stream envia dados → ring buffers enchem → produtor bloqueia em `rb.Write`
- Auto-scaler do agente vê `producerBps=0`, `drainBps=0` → **deadlock completo**

## Proposed Changes

### Server Handler

#### [MODIFY] [handler.go](file:///home/lucas/Projects/n-backup/internal/server/handler.go)

**Correção 1 — Contadores independentes para flow rotation:**

O `evaluateFlowRotation` deve ter seus **próprios contadores** que acumulam independentemente do `logPerStreamStats`. Usar Load sem Swap.

A solução é inverter a ordem e usar `Load` no `logPerStreamStats` seguido de `Swap(0)` no `evaluateFlowRotation`, ou melhor: o flow rotation deve **acumular seus próprios bytes** via um `StreamTrafficFR` separado.

> [!IMPORTANT]
> A abordagem **mais simples e definitiva**: `evaluateFlowRotation` é chamado ANTES de `logPerStreamStats`, e AMBOS fazem `Load()`. O `logPerStreamStats` faz o `Swap(0)` no final para resetar. Assim o flow rotation vê o valor **antes** do reset.

**Correção 2 — Limite de rotações simultâneas:**

Adicionar `MaxRotationsPerTick = 1` — no máximo 1 stream é rotado por ciclo de avaliação (15s). Isso evita a tempestade de reconexões e garante que pelo menos N-1 streams continuem drenando dados.

## Mudanças Concretas

```diff
 // StartStatsReporter — reordenar para chamar flow rotation ANTES do reset
 case <-ticker.C:
+    // Flow Rotation ANTES do reset de counters
+    if h.cfg.FlowRotation.Enabled {
+        h.evaluateFlowRotation(secs)
+    }
+
     // Swap-and-reset: lê o acumulado e zera
     trafficIn := h.TrafficIn.Swap(0)
     diskWrite := h.DiskWrite.Swap(0)
     conns := h.ActiveConns.Load()
     ...
     if h.cfg.Logging.StreamStats {
         h.logPerStreamStats(secs)
     }
-    if h.cfg.FlowRotation.Enabled {
-        h.evaluateFlowRotation(secs)
-    }
```

```diff
 // evaluateFlowRotation — usa Swap(0) internamente para ler bytesdo intervalo
-bytes := counter.Load()
+bytes := counter.Swap(0)
 mbps := float64(bytes) / intervalSecs / (1024 * 1024)
```

```diff
 // evaluateFlowRotation — limitar a 1 rotação por tick
+var rotated int
+const maxRotationsPerTick = 1
 ...
-if sinceMarked >= frCfg.EvalWindow && sinceLast >= frCfg.Cooldown {
+if sinceMarked >= frCfg.EvalWindow && sinceLast >= frCfg.Cooldown && rotated < maxRotationsPerTick {
     if conn, ok := ps.StreamConns.Load(idx); ok {
         ...
         conn.(net.Conn).Close()
+        rotated++
```

E o `logPerStreamStats` muda para **não resetar** (porque o flow rotation já fez o Swap):

```diff
 // logPerStreamStats
-bytes := counter.Swap(0)
+bytes := counter.Load()
```

> [!NOTE]
> Porém, se `StreamStats` estiver desabilitado e flow rotation habilitado, o `evaluateFlowRotation` precisa fazer o Swap. Se ambos estiverem habilitados, o flow rotation faz o Swap e o logPerStreamStats faz Load. A solução final é: **flow rotation SEMPRE faz Swap(0)** e é chamado primeiro.

## Verification Plan

### Automated Tests
```bash
go build ./...
go test ./...
```

### Manual
- Deploy com flow rotation habilitado e verificar que streams não sofrem rotação em massa
- Observar `producerBps` e `drainBps` permanecem > 0 durante operação normal
