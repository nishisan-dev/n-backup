# v2.0.0 â€” Plano de ImplementaÃ§Ã£o

> ConsolidaÃ§Ã£o do brainstorm de melhorias para protocolo, WebUI e persistÃªncia de eventos do n-backup.

---

## VisÃ£o Geral

A v2.0.0 agrupa melhorias em **protocolo**, **observabilidade** e **experiÃªncia da WebUI**, organizadas em fases sugeridas por dependÃªncia lÃ³gica. A ordem final fica a critÃ©rio do autor.

### Fases Sugeridas

| Fase | Foco | DependÃªncia |
|:---:|---|---|
| 1 | Protocolo: Handshake enriquecido | Nenhuma |
| 2 | Storages: Uso de disco na WebUI | Nenhuma |
| 3 | PersistÃªncia de Eventos | Nenhuma |
| 4 | HistÃ³rico de SessÃµes Finalizadas | Depende da Fase 3 |
| 5 | Server Stats (runtime) | Nenhuma |
| 6 | Melhorias UX da WebUI | Nenhuma |

---

## Fase 1: Protocolo â€” Control Channel Handshake Enriquecido

### Contexto

O handshake do control channel hoje envia apenas `CTRL` (4B) + `keepalive_interval` (4B uint32). O agent jÃ¡ envia stats (CPU/Mem/Disk/Load) periodicamente via frames `CSTS`, mas o server nÃ£o tem essas informaÃ§Ãµes atÃ© o primeiro tick de ping (~30s).

### Objetivo

Enriquecer o handshake para enviar **versÃ£o do agent** e **stats iniciais** imediatamente na conexÃ£o.

### Formato do Handshake (novo)

```
[CTRL 4B] [keepalive 4B] [version string\n] [CPU f32] [Mem f32] [Disk f32] [Load f32]
```

### Arquivos Impactados

| Arquivo | MudanÃ§a |
|---|---|
| `internal/agent/control_channel.go` | Enviar version + stats no `connect()` |
| `internal/server/handler.go` | Ler version + stats no `handleControlChannel()`, armazenar em `ControlConnInfo` |
| `internal/protocol/control.go` | FunÃ§Ãµes `WriteControlStatsRaw` / `ReadControlStatsRaw` (sem magic) |
| `internal/protocol/control_test.go` | Teste round-trip para stats raw |

### Detalhes

1. **Agent** (`control_channel.go`):
   - Adicionar campo `version string` na struct `ControlChannel`
   - No `connect()`, apÃ³s enviar magic+keepalive, enviar version (`\n`-terminated) e stats iniciais (16B)
   - Receber version via construtor ou variÃ¡vel de pacote (ldflags)

2. **Server** (`handler.go`):
   - No `handleControlChannel()`, apÃ³s ler keepalive_interval:
     - Ler version via `readUntilNewline(conn)`
     - Ler 16B de stats iniciais
   - Adicionar `ClientVersion string` ao `ControlConnInfo`
   - Popular `ControlConnInfo.Stats` imediatamente

3. **Protocolo** (`control.go`):
   - `WriteControlStatsRaw(w, stats)` â€” escreve 4 float32 sem magic
   - `ReadControlStatsRaw(r)` â€” lÃª 4 float32 sem magic
   - ReutilizÃ¡vel pelo handshake e por testes

> **Nota**: Isso **nÃ£o** altera o `ProtocolVersion` (0x04), pois o canal de controle Ã© independente do protocolo de backup.

---

## Fase 2: WebUI â€” Storages com Uso de Disco

### Contexto

Hoje o `/api/v1/config/effective` expÃµe configuraÃ§Ãµes dos storages (BaseDir, MaxBackups, modo), mas nÃ£o mostra **uso real de disco** nem **quantos backups existem**. O `handleHealthCheck` tem um TODO para implementar `syscall.Statfs`.

### Objetivo

Novo endpoint `/api/v1/storages` que retorna uso de disco real + contagem de backups, com visualizaÃ§Ã£o de gauges na WebUI.

### Arquivos Impactados

| Arquivo | MudanÃ§a |
|---|---|
| `internal/server/observability/dto.go` | Novo DTO `StorageUsage` |
| `internal/server/handler.go` | MÃ©todo `StorageUsageSnapshot()` usando `syscall.Statfs` |
| `internal/server/observability/http.go` | Endpoint `GET /api/v1/storages`, atualizar `HandlerMetrics` |
| `internal/server/observability/http_test.go` | Testes do novo endpoint |
| `web/js/api.js` | `storages()` |
| `web/js/components.js` | `renderOverviewStorages()` com gauges |
| `web/js/app.js` | Chamar storages no `fetchOverview()` |
| `web/index.html` | SeÃ§Ã£o "Storages" no overview |

### DTO

```go
type StorageUsage struct {
    Name            string `json:"name"`
    BaseDir         string `json:"base_dir"`
    MaxBackups      int    `json:"max_backups"`
    CompressionMode string `json:"compression_mode"`
    AssemblerMode   string `json:"assembler_mode"`
    TotalBytes      uint64 `json:"total_bytes"`
    UsedBytes       uint64 `json:"used_bytes"`
    FreeBytes       uint64 `json:"free_bytes"`
    UsagePercent    float64 `json:"usage_percent"`
    BackupsCount    int    `json:"backups_count"`
}
```

### LÃ³gica do Backend

```go
func (h *Handler) StorageUsageSnapshot() []StorageUsage {
    for name, storage := range h.cfg.Storages {
        var stat syscall.Statfs_t
        syscall.Statfs(storage.BaseDir, &stat)
        // TotalBytes = stat.Blocks * Bsize
        // FreeBytes  = stat.Bavail * Bsize
        // UsedBytes  = Total - Free
        // BackupsCount = contar arquivos .tar.gz/.tar.zst no baseDir/**/
    }
}
```

### Frontend

SeÃ§Ã£o "Storages" no Overview com cards por storage:
- Nome e BaseDir
- Gauge bar de uso de disco (mesma estÃ©tica dos gauges de CPU/Mem dos agents)
- `X / Y backups` com indicador visual
- Badge de compressÃ£o (gzip/zst) e assembler mode (eager/lazy)

---

## Fase 3: PersistÃªncia de Eventos

### Contexto

O `EventRing` Ã© um ring buffer in-memory que descarta eventos antigos. No restart do server, todo o histÃ³rico Ã© perdido. A WebUI mostra "Nenhum evento registrado" atÃ© que novos eventos ocorram.

### Objetivo

Persistir eventos em arquivo **JSONL** (append-only, um JSON por linha). No startup, carregar os Ãºltimos N eventos do arquivo para o ring buffer.

### Arquivos Impactados

| Arquivo | MudanÃ§a |
|---|---|
| `internal/server/observability/event_store.go` | **[NOVO]** `EventStore` com append JSONL + reload |
| `internal/server/observability/event_store_test.go` | **[NOVO]** Testes de persistÃªncia |
| `internal/config/server.go` | Campos `events_file` e `events_max_lines` no `WebUIConfig` |
| `internal/server/observability/http.go` | Atualizar router para aceitar `EventStore` |

### Design do `EventStore`

```go
type EventStore struct {
    ring     *EventRing       // buffer em memÃ³ria para queries rÃ¡pidas
    file     *os.File         // arquivo JSONL para persistÃªncia
    mu       sync.Mutex       // protege writes no arquivo
    maxLines int              // rotaÃ§Ã£o quando excede
    path     string
}
```

**OperaÃ§Ãµes**:
- `NewEventStore(path, ringCapacity, maxLines)` â†’ abre/cria arquivo, carrega Ãºltimas N linhas no ring
- `Push(e EventEntry)` â†’ ring.Push(e) + append JSONL no arquivo
- `Recent(limit)` â†’ delega ao ring (rÃ¡pido, in-memory)
- `Close()` â†’ fecha o file handle

**RotaÃ§Ã£o**: quando o arquivo excede `maxLines`, reescreve mantendo as Ãºltimas `maxLines/2` linhas. Simples e eficiente para o volume esperado.

### Config

```yaml
web_ui:
  enabled: true
  events_file: "/var/lib/nbackup/events.jsonl"   # default: events.jsonl no CWD
  events_max_lines: 10000                         # default: 10000
```

---

## Fase 4: HistÃ³rico de SessÃµes Finalizadas

### Contexto

Hoje a WebUI sÃ³ mostra sessÃµes **ativas**. Quando uma sessÃ£o termina (sucesso ou falha), ela desaparece do `sync.Map` e nÃ£o hÃ¡ registro.

### Objetivo

Manter um histÃ³rico das Ãºltimas N sessÃµes finalizadas com resultado (sucesso/falha/checksum mismatch).

### EstratÃ©gia

1. **Evento de finalizaÃ§Ã£o**: Quando `handleBackup` ou `handleParallelSession` termina, emitir um evento tipado `session_complete` ou `session_failed` no `EventStore` com metadados:
   - `session_id`, `agent`, `storage`, `backup`, `bytes_total`, `duration`, `result` (ok/checksum_mismatch/write_error)

2. **Ring de sessÃµes finalizadas**: Um `SessionHistoryRing` simples (cap ~100) que mantÃ©m `SessionSummary` + resultado. Populado no momento da finalizaÃ§Ã£o.

3. **Endpoint**: `GET /api/v1/sessions/history` â€” retorna o ring de sessÃµes finalizadas.

4. **Frontend**: Na aba SessÃµes, adicionar toggle "Ativas | Recentes" e listar as sessÃµes finalizadas com badge de resultado (âœ…/âŒ/âš ï¸).

### Arquivos Impactados

| Arquivo | MudanÃ§a |
|---|---|
| `internal/server/handler.go` | Emitir evento e popular history ring na finalizaÃ§Ã£o |
| `internal/server/observability/dto.go` | DTO `SessionHistoryEntry` com resultado |
| `internal/server/observability/http.go` | Endpoint `GET /api/v1/sessions/history` |
| `web/js/api.js` | `sessionsHistory()` |
| `web/js/components.js` | `renderSessionsHistory()` |
| `web/js/app.js` | Toggle ativas/recentes |

---

## Fase 5: Server Stats (Runtime)

### Contexto

O Overview mostra apenas uptime, versÃ£o do Go e status. NÃ£o hÃ¡ visibilidade sobre a saÃºde do prÃ³prio processo do server.

### Objetivo

Expor mÃ©tricas do runtime Go no endpoint de health e na WebUI.

### Dados

```go
type ServerStats struct {
    GoRoutines    int     `json:"goroutines"`
    HeapAllocMB   float64 `json:"heap_alloc_mb"`
    HeapSysMB     float64 `json:"heap_sys_mb"`
    GCPauseMs     float64 `json:"gc_pause_ms"`     // Ãºltima pausa
    GCCycles      uint32  `json:"gc_cycles"`
    CPUCores      int     `json:"cpu_cores"`
}
```

### ImplementaÃ§Ã£o

- Coletar via `runtime.NumGoroutine()`, `runtime.ReadMemStats()`, `runtime.NumCPU()`
- Incluir no `HealthResponse` ou criar endpoint separado `GET /api/v1/server/stats`
- No frontend, adicionar ao card "Server Info" com gauges para memÃ³ria e goroutines

### Arquivos Impactados

| Arquivo | MudanÃ§a |
|---|---|
| `internal/server/observability/dto.go` | DTO `ServerStats` |
| `internal/server/observability/http.go` | Enriquecer `/health` ou novo endpoint |
| `web/js/components.js` | Renderizar stats no Server Info |
| `web/index.html` | Campos adicionais no info-grid |

---

## Fase 6: Melhorias UX da WebUI

### 6.1 Dark/Light Theme Toggle

- Toggle no topbar com Ã­cone ğŸŒ™/â˜€ï¸
- CSS variables para ambos os temas
- PersistÃªncia em `localStorage`
- O tema dark atual vira o default

**Arquivos**: `style.css`, `index.html`, `app.js`

### 6.2 Server-Sent Events (SSE) para Eventos

Substituir (ou complementar) o polling de 2s por SSE para eventos crÃ­ticos:

- Endpoint `GET /api/v1/events/stream` â†’ SSE stream
- Frontend subscreve e mostra toasts para eventos `error` e `warn`
- Polling continua para mÃ©tricas e sessÃµes (que mudam frequentemente)
- SSE apenas para notificaÃ§Ãµes push de eventos

**Arquivos**: `http.go`, `event_store.go` (broadcast channel), `app.js`, `components.js`

### 6.3 Export de Eventos

- BotÃ£o "Export" na aba Eventos
- Download como JSON ou CSV
- ImplementaÃ§Ã£o 100% frontend (usa dados jÃ¡ carregados via API)

**Arquivos**: `components.js`, `index.html`

### 6.4 Alertas Visuais com Thresholds

Regras visuais automÃ¡ticas (sem config â€” puramente frontend):

| CondiÃ§Ã£o | Feedback Visual |
|---|---|
| Disco storage > 90% | Gauge vermelho + Ã­cone âš ï¸ |
| Agent offline > 5min | Badge de warning no card |
| Throughput < 1 MB/s | Indicador amarelo no stream |
| SessÃ£o idle > 60s | Status "degraded" com cor |

**Arquivos**: `components.js`, `style.css`

### 6.5 Responsividade Mobile

Ajustes CSS para viewports estreitos:
- Cards em coluna Ãºnica
- Tabelas com scroll horizontal
- Nav tabs em Ã­cones-only
- Topbar compacto

**Arquivos**: `style.css` (media queries)

### 6.6 Throughput Global Chart no Overview

Mini grÃ¡fico de Ã¡rea no Overview mostrando throughput agregado dos Ãºltimos 15 minutos:
- Reutilizar componente `drawSparkline` existente
- Ring buffer global em `app.js` (jÃ¡ existe o pattern em `sparkHistory`)
- Canvas maior no card de "Traffic In"

**Arquivos**: `app.js`, `components.js`, `index.html`

---

## VerificaÃ§Ã£o Geral

### Testes Automatizados

```bash
cd /home/lucas/Projects/n-backup && go test ./... -v -count=1
```

Testes especÃ­ficos por componente:
```bash
# Protocolo
go test ./internal/protocol/... -v -run TestControl

# Events & Persistence
go test ./internal/server/observability/... -v -run TestEvent

# HTTP endpoints
go test ./internal/server/observability/... -v -run TestStorages
go test ./internal/server/observability/... -v -run TestAgents
```

### VerificaÃ§Ã£o Manual

1. **Storages**: Acessar WebUI â†’ Overview â†’ verificar seÃ§Ã£o Storages com gauges reais
2. **Eventos Persistentes**: Reiniciar server â†’ verificar que eventos anteriores aparecem
3. **HistÃ³rico de SessÃµes**: Completar um backup â†’ verificar aba "Recentes" na WebUI
4. **Server Stats**: Verificar goroutines, heap e GC no card Server Info
5. **Tema**: Toggle dark/light â†’ verificar persistÃªncia ao recarregar pÃ¡gina

---

## Resumo de Prioridades (sugestÃ£o)

| Prioridade | Fase | Justificativa |
|:---:|---|---|
| ğŸ”´ P0 | F1 â€” Handshake enriquecido | FundaÃ§Ã£o do protocolo |
| ğŸ”´ P0 | F2 â€” Storages na WebUI | Visibilidade operacional crÃ­tica |
| ğŸ”´ P0 | F3 â€” PersistÃªncia de eventos | Dados se perdem no restart |
| ğŸŸ¡ P1 | F4 â€” HistÃ³rico de sessÃµes | Complementa F3, alto valor |
| ğŸŸ¡ P1 | F5 â€” Server Stats | Custo baixo, valor alto |
| ğŸŸ¢ P2 | F6.1 â€” Theme toggle | UX polimento |
| ğŸŸ¢ P2 | F6.4 â€” Alertas visuais | UX polimento, zero backend |
| ğŸŸ¢ P2 | F6.6 â€” Throughput global | UX polimento, zero backend |
| ğŸ”µ P3 | F6.2 â€” SSE | Complexidade maior, pode vir depois |
| ğŸ”µ P3 | F6.3 â€” Export eventos | Nice-to-have |
| ğŸ”µ P3 | F6.5 â€” Mobile | Nice-to-have |
