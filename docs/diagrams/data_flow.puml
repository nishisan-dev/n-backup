@startuml data_flow
!theme plain
skinparam backgroundColor #FEFEFE
skinparam defaultFontName Inter
skinparam activityDiamondBackgroundColor #FFE082

title NBackup — Fluxo de Dados (Single Stream)

start

:Scheduler dispara backup\n(cron expression);

partition "Agent — Preparação" {
  :Carregar config YAML;
  :Resolver backup entries;
}

repeat
  partition "Agent — Backup Entry" {
    :Conectar ao Server\n(TCP + TLS 1.3 mTLS);

    if (Conexão OK?) then (sim)
      :Enviar **HANDSHAKE**\n(magic NBKP + agent + storage);
    else (não)
      :Retry com\nexponential backoff;
      if (Max attempts?) then (sim)
        :Log error, abortar entry;
        stop
      else (não)
        :Aguardar delay;
        backward :Reconectar;
      endif
    endif

    :Receber **ACK** do Server;

    if (Status == GO?) then (sim)
    else (BUSY/FULL/REJECT)
      :Log warning;
      :Encerrar conexão;
      stop
    endif
  }

  partition "Agent — Streaming" {
    fork
      :fs.WalkDir\n(glob include/exclude);
      :tar.Writer\n(preserva paths, perms);
      :gzip.Writer\n(compressão inline);
      :io.TeeReader\n(SHA-256 inline);
      :RingBuffer\n(backpressure);
    fork again
      :Sender goroutine\n(lê buffer → tls.Conn);
    fork again
      :ACK reader\n(processa SACKs);
      :Avança tail do buffer;
    end fork
  }

  partition "Agent — Finalização" {
    :Fechar tar.Writer\ne gzip.Writer;
    :Enviar **TRAILER**\n(SHA-256 + size);
  }

  partition "Server — Recepção" {
    :io.Copy → arquivo .tmp;
    :Calcular SHA-256\n(io.MultiWriter);
    if (Checksum match?) then (sim)
      :Rename .tmp → timestamp.tar.gz\n(atomic rename);
      :Rotação: remover excedentes\n(max_backups);
      :Enviar **FINAL ACK**\n(status OK);
    else (não)
      :Remover .tmp;
      :Enviar **FINAL ACK**\n(CHECKSUM_MISMATCH);
    endif
  }

repeat while (Mais backup entries?) is (sim)
->não;

:Todos os backups concluídos;

stop

@enduml
